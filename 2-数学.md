[TOC]

# 数学



## 数论



### 莫比乌斯反演（筛积性函数+数论分块）

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e5;
int mu[maxn+50],prime[maxn+50],sum[maxn+50];
bool f[maxn+50];
int a,b,c,d,k;
long long solve(int n,int m)
{
    if(n>m) swap(n,m);
    long long ans=0;
    for(int i=1,la=0;i<=n;i=la+1)
    {
        la=min(n/(n/i),m/(m/i));
        ans+=(long long)(sum[la]-sum[i-1])*(n/i)*(m/i);
    }//对于n/i * m/i 采用分块求和的根号n+根号m的做法
    return ans;
}
int main()
{
    mu[1]=1;
    memset(f,0,sizeof(f));
    f[1]=1;
    for(int i=2;i<=maxn;++i)
    {
        if(!f[i])
        {
            prime[++prime[0]]=i;
            mu[i]=-1;
        }
        for(int j=1;j<=prime[0];++j)
        {
            if(i*prime[j]>maxn) break;
            f[i*prime[j]]=1;
            if(i%prime[j]==0)
            {
                mu[i*prime[j]]=0;
                break;
            }
            else mu[i*prime[j]]=-mu[i];
        }
    }//筛积性函数
    memset(sum,0,sizeof(sum));
    sum[1]=mu[1];
    for(int i=2;i<=maxn;++i) sum[i]=sum[i-1]+mu[i];
    int T;
    scanf("%d",&T);
    for(int cas=1;cas<=T;++cas)
    {
        printf("Case %d: ",cas);
        scanf("%d%d%d%d%d",&a,&b,&c,&d,&k);
        if(k==0) printf("0\n");else
        {
            long long ans=solve(b/k,d/k)-solve((a-1)/k,d/k)-solve(b/k,(c-1)/k)+solve((a-1)/k,(c-1)/k);
            a=max(a,c),b=min(b,d);
            long long ans1=solve(b/k,b/k)-solve((a-1)/k,b/k)-solve(b/k,(a-1)/k)+solve((a-1)/k,(a-1)/k);
            printf("%lld\n",ans-ans1/2);
        }
    }
    return 0;
}
```



### CRT

```cpp
void gcd(ll a,ll b,ll &d,ll &x,ll &y)
{
    if(!b)
    {
        d=a,x=1,y=0;
        return;
    }
    gcd(b,a%b,d,y,x);
    y-=x*(a/b);
}
ll inv(ll a,ll n)
{
    ll d,x,y;
    gcd(a,n,d,x,y);
    return d==1?(x+n)%n:-1;
}
ll CRT(int n,ll *a,ll *m)
{
    /*n个方程 x=a[i] (mod m[i])   (0<=i<n)*/
    ll M=1,d,y,x=0;
    for(int i=0;i<n;++i) M*=m[i];
    for(int i=0;i<n;++i)
    {
        ll w=M/m[i];
        gcd(m[i],w,d,d,y);
        x=(x+y*w*a[i])%M;
    }
    return (x+M)%M;
}
```



### 类欧几里得

```cpp
typedef long long ll;
ll solve(ll a,ll b,ll c,ll n)
{
    /*
    计算 \sum_{i=0..n} (ax+b)/c 的值
    */
    if(n<0) return 0;
    if(c<0) a=-a,b=-b,c=-c;
    if(a<0) b+=a*n,a=-a;
    if(b<0)
    {
        ll p=(-b)/c+1;
        //(a*x+b+p*c)/c-p
        return (solve(a,b+p*c,c,n)-p*(n+1))%mod;
    }
    if(a==0)
        return (b/c)*(n+1)%mod;
    if(a>=c)
        return (n*(n+1)/2%mod*(a/c)%mod+solve(a%c,b,c,n))%mod;
    if(b>=c)
        return ((b/c)*(n+1)%mod+solve(a,b%c,c,n))%mod;
    //LL m=(a*n+b)/c%MOD;
    ll m=(n/c*a+(n%c*a+b)/c);
    return ((m%mod)*(n%mod)%mod-solve(c,c-b-1,a,m-1)+mod)%mod;
}
ll cal(ll a,ll b,ll c,ll n)
{
/*
计算y=(ax+b)/c下方整点个数，x=0..n
要求a>=0,c>0
*/
    if(b>=0) return (solve(a,b,c,n)+n%mod+1)%mod;
    ll x=(-b)/a;
    if(x*a+b<0) ++x;
    if(n<x) return 0;
    b+=a*x;
    return (solve(a,b,c,n-x)+(n-x)%mod+1)%mod;
}
```



### 杜教筛

```cpp
#include<bits/stdc++.h>
#define debug cout<<"debug "<<++debug_num<<" :"
#define pb push_back
#define mp make_pair
#define lson l,m,rt<<1
#define rson m+1,r,rt<<1|1
#define bit(a,b) ((a>>b)&1) //from 0
#define all(x) (x).begin(),(x).end()
using namespace std;
typedef long long ll;
typedef pair<int,int> PII;
int debug_num=0;

const int maxn=5e6+10;
bool valid[maxn];
ll phi[maxn];
int mu[maxn];
int ans[maxn/10];
int tot;
int up;
int m;
const int maxm=(1LL<<32)/maxn;
ll help1[maxm];
int help2[maxm];
bool vis[maxm];

void get_prime(int n)
{
    memset(valid,true,sizeof(valid));
    tot=0;
    phi[1]=mu[1]=1;
    for(int i=2;i<=n;++i){
        if(valid[i]){
            ans[++tot]=i;
            mu[i]=-1;
            phi[i]=i-1;
        }
        for(int j=1;j<=tot && i*ans[j]<=n;++j){
            int tp=i*ans[j];
            valid[tp]=false;
            if(i%ans[j]==0){
                mu[tp]=0;
                phi[tp]=phi[i]*ans[j];
                break;
            }
            else{
                mu[tp]=-mu[i];
                phi[tp]=phi[i]*(ans[j]-1);
            }
        }
    }
    for(int i=1;i<=n;++i){
        phi[i]=phi[i-1]+phi[i];
        mu[i]+=mu[i-1];
    }
}

ll get_phi(ll n)
{
    return (n<=up)? phi[n] : help1[m/n];
}

ll get_mu(ll n)
{
    return (n<=up)? mu[n] : help2[m/n];
}

void solve(ll n)
{
    int t=m/n;
    if(n<=up || vis[t]) return ;
    vis[t]=true;
    help1[t]=n*(n+1)/2;//单位函数前缀和
    help2[t]=1;//恒等函数前缀和
    for(ll l=2,r;l<=n;l=r+1){
        r=n/(n/l);
        solve(n/r);
        help1[t]=help1[t]-(r-l+1)*get_phi(n/r);
        help2[t]=help2[t]-(r-l+1)*get_mu(n/r);
    }
}

int main()
{
    //freopen("in.txt","r",stdin);
    up=maxn-10;
    get_prime(up);
    //cout<<clock()<<endl;
    //cout<<tot<<endl;
    //cout<<phi[up]<<endl;
    //for(int i=1;i<=up;++i) if(mu[i]==0) cout<<"fuck"<<endl;
    int t,n;
    cin>>t;
    while(t--)
    {
        cin>>n;
        m=n;
        if(n<=up) cout<<phi[n]<<" "<<mu[n]<<endl;
        else{
            memset(vis,0,sizeof(vis));//注意清空
            solve(n);
            cout<<help1[1]<<" "<<help2[1]<<endl;
        }
    }
    return 0;
}
```



### O(1)快速乘

```cpp
inline ll multi(ll x,ll y,ll mod)
{
	ll tmp=(x*y-(ll)((long double)x/mod*y+1.0e-8)*mod);
    return tmp<0 ? tmp+mod : tmp;
}
```



### min25筛

```cpp
//f(1)=1
//f(p)=p^2-p
//f(p^e)=(p-1)p^(2e-1)
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll mod=1e9+7,inv6=166666668;
ll n,M;
//pre[d][i]预处理的是2~i中的p^d的和 p是素数
//suf[d][i]预处理2~n/i的p^d的和 p是素数
//pre[0][i]预处理的是2~i中p^2-p的和 p是素数
//suf[0][i]预处理的是2~n/i中p^2-p的和 p是素数
vector<ll> pre[3],suf[3],prime;
//res是n/枚举的数
ll mul(ll a,ll b)
{
    return a*b%mod;
}
ll add(ll a,ll b)
{
    return (a+b)%mod;
}
ll sub(ll a,ll b)
{
    return (a-b)%mod;
}
ll dfs(ll res,int last,ll f)
{
    ll t=(res>M?suf[0][n/res]:pre[0][res])-pre[0][prime[last]-1];
    t%=mod;
    ll ans=mul(t,f);//需要修改
    for(int i=last;i<(int)prime.size();++i)
    {
        int p=prime[i];
        if(1LL*p*p>res) break;
        for(ll q=p,nres=res,nf=f*p%mod*(p-1)%mod;q*p<=res;q*=p)//nf需要修改
        {
            ans=add(ans,dfs(nres/=p,i+1,nf));   //枚举更大的数
            nf=mul(nf,mul(p,p));    //需要修改，继续枚举当前素数，指数大于1的时候，指数每+1，nf*=p^2
            ans=add(ans,nf);        //指数大于1的时候记上贡献
        }
    }
    return ans;
}
ll f(ll x)
{
    return x*(1+x)/2%mod;
}
ll ff(ll x)
{
    return x*(x+1)%mod*(2*x+1)%mod*inv6%mod;
}
ll solve(ll n)
{
    M=sqrt(n);
    for(int i=0;i<3;++i) pre[i].clear(),pre[i].resize(M+1);
    for(int i=0;i<3;++i) suf[i].clear(),suf[i].resize(M+1);
    prime.clear();
    for(int i=1;i<=M;++i)
    {
        pre[1][i]=f(i)-1;
        suf[1][i]=f(n/i)-1;
        pre[2][i]=ff(i)-1;
        suf[2][i]=ff(n/i)-1;
    }
    for(int p=2;p<=M;++p)
    {
        if(pre[1][p]==pre[1][p-1]) continue;
        prime.push_back(p);
        const ll q=1LL*p*p,m=n/p,pnt[3]={0,pre[1][p-1],pre[2][p-1]};
        const int mid=M/p;
        const int End=min((ll)M,n/q);
        for(int i=1;i<=mid;++i)
        {
            suf[1][i]=sub(suf[1][i],(suf[1][i*p]-pnt[1])*p%mod);
            suf[2][i]=sub(suf[2][i],(suf[2][i*p]-pnt[2])*p%mod*p%mod);
        }
        for(int i=mid+1;i<=End;++i)
        {
            suf[1][i]=sub(suf[1][i],(pre[1][m/i]-pnt[1])*p%mod);
            suf[2][i]=sub(suf[2][i],(pre[2][m/i]-pnt[2])*p%mod*p%mod);
        }
        for(int i=M;i>=q;--i)
        {
            pre[1][i]=sub(pre[1][i],(pre[1][i/p]-pnt[1])*p%mod);
            pre[2][i]=sub(pre[2][i],(pre[2][i/p]-pnt[2])*p%mod*p%mod);
        }
    }
    for(int i=1;i<=M;++i)
    {
        pre[0][i]=(pre[2][i]-pre[1][i])%mod;
        suf[0][i]=(suf[2][i]-suf[1][i])%mod;
    }
    prime.push_back(M+1);
    return n>1?1+dfs(n,0,1):1;
}
int main()
{
    scanf("%lld",&n);
    printf("1\n%lld\n",(solve(n)+mod)%mod);
    return 0;
}
```



### 矩阵类

```cpp
struct matrix
{
    int n,a[N][N];
    matrix operator *(const matrix&b) const
    {
        matrix c;c.n=n;memset(c.a,0,sizeof(c.a));
        for (int i=0;i<n;i++)
            for (int j=0;j<b.n;j++)
                for (int k=0;k<b.n;k++)
                c.a[i][j]=(c.a[i][j]+1ll*a[i][k]*b.a[k][j])%P;
        return c;
    }
}
```



## 多项式



### FFT

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=400000;
const double pi=acos(-1.0);
int l,m,n,num;
int a[maxn+50],b[maxn+50];
struct wjmzbmr
{
    double r,i;
    wjmzbmr(double real=0.0,double image=0.0){r=real;i=image;}
    wjmzbmr operator + (const wjmzbmr o)
    {
        return wjmzbmr(r+o.r,i+o.i);
    }
    wjmzbmr operator - (const wjmzbmr o)
    {
        return wjmzbmr(r-o.r,i-o.i);
    }
    wjmzbmr operator * (const wjmzbmr o)
    {
        return wjmzbmr(r*o.r-i*o.i,r*o.i+i*o.r);
    }
};
wjmzbmr x1[maxn+50],x2[maxn+50];
void brc(wjmzbmr *y,int l)
{
    for(int i=1,j=l/2;i<l-1;i++)
    {
        if(i<j) swap(y[i],y[j]);
        int k=l/2;
        while(j>=k)j-=k,k/=2;
        if(j<k) j+=k;
    }
}
void fft(wjmzbmr *y,int l,double on)
{
    wjmzbmr u,t;
    brc(y,l);
    for(int h=2;h<=l;h<<=1)
    {
        wjmzbmr wn(cos(on*2*pi/h),sin(on*2*pi/h));
        for(int j=0;j<l;j+=h)
        {
            wjmzbmr w(1,0);
            for(int k=j;k<j+h/2;k++)
            {
                u=y[k];
                t=w*y[k+h/2];
                y[k]=u+t;
                y[k+h/2]=u-t;
                w=w*wn;
            }
        }
    }
    if(on==-1)for(int i=0;i<l;i++) y[i].r/=l;
}
void init(int *a,int n,wjmzbmr *x1,int *b,int m,wjmzbmr *x2)
{
    /*将a[0]~a[n-1]放到x1中，将b[0]~b[m-1]放到x2中*/
    l=1;
    while(l<max(n,m)*2) l<<=1;
    for(int i=0;i<n;++i)
    {
        x1[i].r=a[i];
        x1[i].i=0.0;
    }
    for(int i=n;i<l;++i)x1[i].r=x1[i].i=0.0;
    for(int i=0;i<m;++i)
    {
        x2[i].r=b[i];
        x2[i].i=0.0;
    }
    for(int i=m;i<l;i++) x2[i].r=x2[i].i=0.0;
}
int main()
{
    scanf("%d %d",&n,&m);
    ++n,++m;
    for(int i=0;i<n;++i) scanf("%d",&a[i]);
    for(int i=0;i<m;++i) scanf("%d",&b[i]);
    init(a,n,x1,b,m,x2);
    fft(x1,l,1);
    fft(x2,l,1);
    for(int i=0;i<l;++i) x1[i]=x1[i]*x2[i];
    fft(x1,l,-1);
    for(int i=0;i<n+m-1;++i) printf("%lld ",(long long)(x1[i].r+0.5));
    return 0;
}
```



### 任意模数FFT

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=524300,mod=1e9+7;
int n;
int A[maxn+5],B[maxn+5],C[maxn+5];
int len;
int pos[maxn+5];
namespace FFT
{
    /*
    模任意质数mod的FFT
    */
    const int M=1000;
    struct comp
    {
        long double r,i;
        comp(long double _r=0,long double _i=0){r=_r;i=_i;}
        comp operator+(const comp x){return comp(r+x.r,i+x.i);}
        comp operator-(const comp x){return comp(r-x.r,i-x.i);}
        comp operator*(const comp x){return comp(r*x.r-i*x.i,r*x.i+i*x.r);}
        comp conj(){return comp(r,-i);}
    }A[maxn+5],B[maxn+5];
    int a0[maxn+5],b0[maxn+5],a1[maxn+5],b1[maxn+5];
    const long double pi=acos(-1.0);
    void FFT(comp a[],int n,int t)
    {
        for(int i=1;i<n;i++)
            if(i<pos[i])swap(a[i],a[pos[i]]);
        for(int d=0;(1<<d)<n;d++)
        {
            int m=1<<d,m2=m<<1;
            long double o=pi*2/m2*t;comp _w(cos(o),sin(o));
            for(int i=0;i<n;i+=m2)
            {
                comp w(1,0);
                for(int j=0;j<m;j++)
                {
                    comp&A=a[i+j+m],&B=a[i+j],t=w*A;
                    A=B-t;B=B+t;w=w*_w;
                }
            }
        }
        if(t==-1)for(int i=0;i<n;i++)a[i].r/=n;
    }
    void mul(int*a,int*b,int*c,int len)
    {//c=a*b
        for(int i=0;i<len;i++)A[i]=comp(a[i],b[i]);
        FFT(A,len,1);
        for(int i=0;i<len;i++)
        {
            int j=(len-i)&(len-1);
            B[i]=(A[i]*A[i]-(A[j]*A[j]).conj())*comp(0,-0.25);
        }
        FFT(B,len,-1);
        for(int i=0;i<len;i++)c[i]=((long long)(B[i].r+0.5))%mod;
    }
    //输入两个多项式，求a*b mod mod，保存在c中，c不能为a或b，长度为0~len-1
    void mulmod(int*a,int*b,int*c,int len)
    {
        for(int i=0;i<len;i++)a0[i]=a[i]/M,b0[i]=b[i]/M;
        mul(a0,b0,a0,len);
        for(int i=0;i<len;i++)
        {
            c[i]=1LL*a0[i]*M*M%mod;
            a1[i]=a[i]%M,b1[i]=b[i]%M;
        }
        mul(a1,b1,a1,len);
        for(int i=0;i<len;i++)
        {
            c[i]=(a1[i]+c[i])%mod,a0[i]=(a0[i]+a1[i])%mod;
            a1[i]=a[i]/M+a[i]%M,b1[i]=b[i]/M+b[i]%M;
        }
        mul(a1,b1,a1,len);
        for(int i=0;i<len;i++)c[i]=(1LL*M*(a1[i]-a0[i]+mod)+c[i])%mod;
    }
}
int main()
{
    for(len=1;len<=n;len<<=1);len<<=1;
    int x=__builtin_ctz(len)-1;
    for(int i=0;i<len;i++)pos[i]=pos[i>>1]>>1|((i&1)<<x);
    for(int i=2;i<=n;i++) A[i]=1LL*pa[n-i]*inv[n-i]%mod;
    for(int i=2;i<=n;i++) B[i]=1LL*pb[n-i]*inv[n-i]%mod;
    FFT::mulmod(A,B,C,len);
    return 0;
}
```



### NTT

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxn=262144*4;
//const long long P=50000000001507329LL; // 190734863287 * 2 ^ 18 + 1
//const int P=1004535809; // 479 * 2 ^ 21 + 1
const ll mod=998244353; // 119 * 2 ^ 23 + 1
const ll G=3;

ll len=0;
ll pw[maxn+5],pwinv[maxn+5];
ll A[maxn+5],B[maxn+5];
ll f[maxn+5];
int n,m;

ll Pow(ll a,ll b,ll mod)
{
    ll ans=1;
    while(b)
    {
        if(b&1) ans=ans*a%mod;
        a=a*a%mod;
        b>>=1;
    }
    return ans;
}
ll Inv(ll x)
{
    return Pow(x,mod-2,mod);
}
void Init()
{
    ll inv=Inv(G);
    for (int i=1;i<=maxn;i<<=1)
    {
        pw[i]=Pow(G,(mod-1)/i,mod);
        pwinv[i]=Pow(inv,(mod-1)/i,mod);
    }
}
void rader(ll *a)
{
    for(int i=0,j=0;i<len;i++)
    {
        if(i>j) swap(a[i],a[j]);
        int k=len;
        do{k>>=1;j^=k;}while(j<k);
    }
}
void ntt(ll *a,int f)
{
    rader(a);
    for(int i=2;i<=len;i<<=1)
    {
        int m=i>>1;
        for(int j=0;j<len;j+=i)
        {
            ll w=1,wn=pw[i];
            if(f==-1) wn=pwinv[i];
            for(int k=0;k<m;k++)
            {
                ll x=a[j+k+m]*w%mod;
                a[j+k+m]=(a[j+k]-x+mod)%mod;
                a[j+k]=(a[j+k]+x)%mod;
                w=w*wn%mod;
            }
        }
    }
    if(f==-1)
    {
        ll inv=Inv(len);
        for(int i=0;i<len;i++) a[i]=a[i]*inv%mod;
    }
}
void con(ll *A,int n,ll *B,int m)
{
    /*A[0..n-1]与B[0..m-1]卷积*/
    for(len=1;len<max(n,m);len<<=1);
    len<<=1;
    for(int i=n;i<len;++i) A[i]=0;
    for(int i=m;i<len;++i) B[i]=0;
    ntt(A,1);
    ntt(B,1);
    for(int i=0;i<len;++i) A[i]=A[i]*B[i]%mod;
    ntt(A,-1);
}
int main()
{
    Init();
    con(A,n,B,m);
    return 0;
}
```



### FWT

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1024,mod=1e9+7,rev=(mod+1)>>1;
int a[maxn+50],b[maxn+50];
long long fc[maxn*maxn];
int T,n,m;
void fwt(int *a,int n)
{
    for(int d=1;d<n;d<<=1)
        for(int m=d<<1,i=0;i<n;i+=m)
            for(int j=0;j<d;j++)
            {
                int x=a[i+j],y=a[i+j+d];
                a[i+j]=(x+y)%mod,a[i+j+d]=(x-y+mod)%mod;
                //xor:a[i+j]=x+y,a[i+j+d]=(x-y+mod)%mod;
                //and:a[i+j]=x+y;
                //or:a[i+j+d]=x+y;
            }
}
void ufwt(int *a,int n)
{
    for(int d=1;d<n;d<<=1)
        for(int m=d<<1,i=0;i<n;i+=m)
            for(int j=0;j<d;j++)
            {
                int x=a[i+j],y=a[i+j+d];
                a[i+j]=1LL*(x+y)*rev%mod,a[i+j+d]=(1LL*(x-y)*rev%mod+mod)%mod;
                //xor:a[i+j]=(x+y)/2,a[i+j+d]=(x-y)/2;
                //and:a[i+j]=x-y;
                //or:a[i+j+d]=y-x;
            }
}
void solve(int *a,int *b,int n)//下标0..n-1的数组a和b求异或卷积，O(nlogn)，返回值在a中
{
    fwt(a,n);
    fwt(b,n);
    for(int i=0;i<n;++i) a[i]=1LL*a[i]*b[i]%mod;
    ufwt(a,n);
}
int main()
{
    fc[0]=1;
    for(int i=1;i<=1000000;++i) fc[i]=fc[i-1]*i%mod;
    scanf("%d",&T);
    while(T--)
    {
        scanf("%d%d",&n,&m);
        memset(a,0,sizeof(a));
        memset(b,0,sizeof(b));
        for(int i=1;i<=n;++i) a[i]=1;
        for(int i=1;i<=m;++i) b[i]=1;
        solve(a,b,maxn);
        long long ans=1;
        for(int i=0;i<maxn;++i) ans=ans*fc[a[i]]%mod;
        printf("%lld\n",ans);
    }
    return 0;
}
```



### BM算法(模数只能是质数)

```cpp
#include<bits/stdc++.h>
using namespace std;
#define rep(i,a,n) for (int i=a;i<n;i++)
#define per(i,a,n) for (int i=n-1;i>=a;i--)
#define pb push_back
#define mp make_pair
#define all(x) (x).begin(),(x).end()
#define fi first
#define se second
#define SZ(x) ((int)(x).size())
typedef vector<int> VI;
typedef long long ll;
typedef pair<int,int> PII;
const ll mod=1000000007;
ll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}
// head

ll n;
namespace linear_seq {
    const int N=10010;
    ll res[N],base[N],_c[N],_md[N];

    vector<int> Md;
    void mul(ll *a,ll *b,int k) {
        rep(i,0,k+k) _c[i]=0;
        rep(i,0,k) if (a[i]) rep(j,0,k) _c[i+j]=(_c[i+j]+a[i]*b[j])%mod;
        for (int i=k+k-1;i>=k;i--) if (_c[i])
            rep(j,0,SZ(Md)) _c[i-k+Md[j]]=(_c[i-k+Md[j]]-_c[i]*_md[Md[j]])%mod;
        rep(i,0,k) a[i]=_c[i];
    }
    int solve(ll n,VI a,VI b) { // a 系数 b 初值 b[n+1]=a[0]*b[n]+...
//        printf("%d\n",SZ(b));
        ll ans=0,pnt=0;
        int k=SZ(a);
        assert(SZ(a)==SZ(b));
        rep(i,0,k) _md[k-1-i]=-a[i];_md[k]=1;
        Md.clear();
        rep(i,0,k) if (_md[i]!=0) Md.push_back(i);
        rep(i,0,k) res[i]=base[i]=0;
        res[0]=1;
        while ((1ll<<pnt)<=n) pnt++;
        for (int p=pnt;p>=0;p--) {
            mul(res,res,k);
            if ((n>>p)&1) {
                for (int i=k-1;i>=0;i--) res[i+1]=res[i];res[0]=0;
                rep(j,0,SZ(Md)) res[Md[j]]=(res[Md[j]]-res[k]*_md[Md[j]])%mod;
            }
        }
        rep(i,0,k) ans=(ans+res[i]*b[i])%mod;
        if (ans<0) ans+=mod;
        return ans;
    }
    VI BM(VI s) {
        VI C(1,1),B(1,1);
        int L=0,m=1,b=1;
        rep(n,0,SZ(s)) {
            ll d=0;
            rep(i,0,L+1) d=(d+(ll)C[i]*s[n-i])%mod;
            if (d==0) ++m;
            else if (2*L<=n) {
                VI T=C;
                ll c=mod-d*powmod(b,mod-2)%mod;
                while (SZ(C)<SZ(B)+m) C.pb(0);
                rep(i,0,SZ(B)) C[i+m]=(C[i+m]+c*B[i])%mod;
                L=n+1-L; B=T; b=d; m=1;
            } else {
                ll c=mod-d*powmod(b,mod-2)%mod;
                while (SZ(C)<SZ(B)+m) C.pb(0);
                rep(i,0,SZ(B)) C[i+m]=(C[i+m]+c*B[i])%mod;
                ++m;
            }
        }
        return C;
    }
    int gao(VI a,ll n) {
        VI c=BM(a);
        c.erase(c.begin());
        rep(i,0,SZ(c)) c[i]=(mod-c[i])%mod;
        return solve(n,c,VI(a.begin(),a.begin()+SZ(c)));
    }
};
vector<int> a;
int main() {
    int T;
    scanf("%d",&T);
    a.clear();
    a.pb(31),a.pb(197),a.pb(1255),a.pb(7997),a.pb(50959),a.pb(324725);
    while(T--)
    {
        scanf("%lld",&n);
        printf("%d\n",linear_seq::gao(a,n-1));
    }
    return 0;
}
```



### k^2logn求线性递推

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=4000,mod=1000000007;
int a[maxn+5],p[maxn+5],ans[maxn+5],num[maxn+5];
int h[maxn+5],tmp[maxn+5];
int n,k;
void mul(int *a,int *b,int *ans)
{
    for(int i=0;i<=2*k;++i) tmp[i]=0;
    for(int i=0;i<k;++i)
        for(int j=0;j<k;++j)
            tmp[i+j]=(tmp[i+j]+1LL*a[i]*b[j])%mod;
    for(int i=2*k-2;i>=k;--i)
    {
        for(int j=k-1;j>=0;--j)
            tmp[i-k+j]=(tmp[i-k+j]-1LL*tmp[i]*p[j])%mod,tmp[i-k+j]=(tmp[i-k+j]+mod)%mod;
        tmp[i]=0;
    }
    for(int i=0;i<k;++i) ans[i]=tmp[i];
}
int main()
{
    scanf("%d%d",&n,&k);
    for(int i=1;i<=k;++i) scanf("%d",&a[i]);
    for(int i=0;i<k;++i) scanf("%d",&h[i]);
    p[k]=1;
    for(int i=1;i<=k;++i) p[k-i]=mod-a[i];
    for(int i=k;i<2*k;++i)
        for(int j=1;j<=k;++j)
        {
            h[i]=h[i]+1LL*h[i-j]*a[j]%mod;
            h[i]%=mod;
        }
    if(n<2*k) return 0*printf("%d\n",h[n]);
    int b=n-k+1;
    num[1]=1,ans[0]=1;
    while(b)
    {
        if(b&1) mul(ans,num,ans);
        mul(num,num,num);
        b>>=1;
    }
    long long res=0;
    for(int i=0;i<k;++i) res=(res+1LL*ans[i]*h[i+k-1])%mod;
    printf("%lld\n",(res+mod)%mod);
    return 0;
}
```





### lagrange插值

```cpp
void mul(int *a,int d,int c)
{
    /*
    a*(x-c)
    */
    int b[maxn+5];
   // memset(b,0,sizeof(b));
    for(int i=0;i<=d;++i) b[i]=a[i];
    for(int i=d+1;i>=1;--i) a[i]=a[i-1];
    a[0]=0;
    for(int i=0;i<=d;++i)
    {
        a[i]=(a[i]-1LL*b[i]*c)%mod;
        if(a[i]<0) a[i]+=mod;
    }
}
void div(int *a,int d,int c,int *ans)
{
    /*
    ans=a/(x-c)
    */
    ans[d-1]=a[d];
    for(int i=d-2;i>=0;--i)
        ans[i]=(a[i+1]+1LL*c*ans[i+1])%mod;
}
void lagrange(int *y,int d,int *p)
{
    /*
    (0,y[0]),(1,y[1]),...,(d,y[d])
    插出的系数放p中
    */
    int tmp[maxn+5],now[maxn+5];
    memset(tmp,0,sizeof(tmp));
    memset(now,0,sizeof(now));
    tmp[0]=1;
    for(int i=0;i<=d;++i)
    {
        mul(tmp,i,i);
    }
    for(int i=0;i<=d;++i)
    {
        for(int j=0;j<=d;++j) now[j]=0;
        div(tmp,d+1,i,now);
        long long q=1;
        for(int j=0;j<=d;++j)
            if(i!=j)
            {
                q=q*(i-j)%mod;
                if(q<0) q+=mod;
            }
        q=inv(q);
        q=q*y[i]%mod;
        for(int j=0;j<=d;++j) now[j]=1LL*now[j]*q%mod;
        for(int j=0;j<=d;++j) p[j]=(p[j]+now[j])%mod;
    }
}
```



### 高斯消元

```cpp
/*
n个未知数，m个方程
*/
#include<bits/stdc++.h>
using namespace std;
const int maxn=1000;
const double eps=1e-6;
double a[maxn+5][maxn+5];
int n,m;
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=m;++i)
        for(int j=1;j<=n+1;++j)
            scanf("%lf",&a[i][j]);
    for(int i=1;i<=n;++i)//枚举列
    {
        if(fabs(a[i][i]-0.0)<=eps)
        {
            int j;
            bool flag=0;
            for(j=i+1;j<=m;++j)
                if(fabs(a[j][i]-0.0)>eps)
                {
                    flag=1;
                    break;
                }
            if(!flag) return 0*printf("Many solutions");//如果第i~m行的第i列都是0，那么多解
            for(int k=1;k<=n+1;++k) swap(a[i][k],a[j][k]);
        }
        for(int j=1;j<=n+1;++j) if(i!=j)a[i][j]/=a[i][i];a[i][i]=1.0;
        for(int j=1;j<=m;++j)
            if(j!=i)
            {
                for(int k=1;k<=n+1;++k) if(k!=i) a[j][k]-=a[i][k]*a[j][i];a[j][i]=0.0;
            }
    }
    for(int i=n+1;i<=m;++i)
        if(fabs(a[i][n+1]-0.0)>eps) return 0*printf("No solutions");//n+1~m这些方程应该所有变量都被消干净了，所以如果不为0，则说明无解
    for(int i=1;i<=n;++i) printf("%d\n",(int)(a[i][n+1]+0.5));
    return 0;
}
```



### 求行列式

```cpp
const int maxn=1000;
ll a[maxn+5][maxn+5];
int turn,n;
void gcd(ll a,ll b,ll &d,ll &x,ll &y)
{
    if(!b) d=a,x=1,y=0;
    else
    {
        ++turn;
        gcd(b,a%b,d,y,x);
        y-=x*(a/b);
    }
}
ll det(ll n)
{
    //求行列式a[0..n-1][0..n-1]
    ll tmp1[maxn+5],tmp2[maxn+5];
    ll ans=1;
    for(int i=0;i<n;++i)
    {
        for(int j=i+1;j<n;++j)
            if(a[j][i]!=0)
            {
                ll A=a[i][i],B=a[j][i],d,x,y;
                turn=0;
                gcd(A,B,d,x,y);
                for(int k=0;k<n;++k) tmp1[k]=a[i][k],tmp2[k]=a[j][k];
                for(int k=0;k<n;++k) a[i][k]=(x*tmp1[k]+y*tmp2[k])%mod;
                A/=d,B/=d;
                if(turn&1) x=B,y=-A,ans=-ans%mod;else x=-B,y=A;
                for(int k=0;k<n;++k) a[j][k]=(x*tmp1[k]+y*tmp2[k])%mod;
            }
        ans=ans*a[i][i]%mod;
    }
    if(ans<0) ans+=mod;
    return ans;
}
```



