[TOC]

# 计算几何

## 二维几何：

### 点与向量

```c++
const double eps=1e-10;
const int PI=acos(-1.0);

struct Point{
    double x,y;
    Point(double x=0,double y=0):x(x),y(y){}
};
typedef Point Vector;

Vector operator -(Point a,Point b){
    return Vector(a.x-b.x,a.y-b.y);
}
Vector operator +(Point a,Point b){
    return Vector(a.x+b.x,a.y+b.y);
}
Vector operator *(Vector a,double p){
    return Vector(a.x*p,a.y*p);
}
Vector operator /(Vector a,double p){
    return Vector(a.x/p,a.y/p);
}
bool operator <(const Point& a,const Point& b){
    return a.x<b.x||(a.x==b.x&&a.y<b.y);//在有精度需求，比如使用lower_bound的时候，加上dcmp()
}
int dcmp(double x){
    if(fabs(x)<eps)return 0;
    if(x<0)return -1;
    return 1;
}
bool operator ==(const Point& a,const Point& b){
    return dcmp(a.x-b.x)==0&&dcmp(a.y-b.y)==0;
}
double Dot(Vector a,Vector b){
    return a.x*b.x+a.y*b.y;
}//点积
double Cross(Vector a,Vector b){
    return a.x*b.y-a.y*b.x;
}//叉积   
double Length(Vector a){
    return sqrt(Dot(a,a));
}//长度
//返回逆时针旋转90度的单位法向量；
Vector Normal(Vector a){
    double l=Length(a);
    return Vector(-a.y/l,a.x/l);
}
//返回向量夹角，无方向
double Angle(Vector a,Vector b){
    return acos(Dot(a,b)/Length(a)/Length(b));
}
//逆时针旋转向量
Vector Rotate(Vector a,double rad){
    return Vector(a.x*cos(rad)-a.y*sin(rad),a.x*sin(rad)+a.y*cos(rad));
}
//求p+v*t与q+w*t的交点，使用时确保Cross(v,w)不等于0
Point GetlineIntersection(Point p,Vector v,Point q,Vector w){
    Vector u=p-q;
    double t=Cross(w,u)/Cross(v,w);
    return p+v*t;
}
//求p到直线ab的距离
double DistanceToline(Point p,Point a,Point b){
    Vector v1=p-a,v2=b-a;
    return fabs(Cross(v1,v2)/Length(v2));
}
//求p到线段ab的距离
double DistanceToSegment(Point p,Point a,Point b){
    if(a==b)return Length(p-a);
    Vector v1=b-a,v2=p-a,v3=p-b;
    if(dcmp(Dot(v1,v2)<0))return Length(p-a);
    else if(dcmp(Dot(v1,v3))>0)return Length(p-b);
    else return fabs(Cross(v1,v2)/Length(v1));
}
//线段a1a2与线段b1b2规范相交返回真
bool SegmenProperIntersection(Point a1,Point a2,Point b1,Point b2){
    double c1=Cross(a2-a1,b1-a1),c2=Cross(a2-a1,b2-a1);
    double c3=Cross(b2-b1,a1-b1),c4=Cross(b2-b1,a2-b1);
    return dcmp(c1)*dcmp(c2)<0&&dcmp(c3)*dcmp(c4)<0;
}
//点p在线段a1a2上返回真
bool OnSegment(Point p,Point a1,Point a2){
    return dcmp(Cross(a1-p,a2-p))==0&&dcmp(Dot(a1-p,a2-p))<0;
}
//点p在ab上的投影
Point GetLineProjection(Point P,Point A,Point B)
{
    Vector v=B-A;
    return A+v*(Dot(v,P-A)/Dot(v,v));
}
//与 x 轴的夹角，取值范围为 (-π，π]
double angle(Vector v){
    return atan2(v.y,v.x);
}
//求线段a1,a2到线段b1,b2的最短距离
double disSegmenttoSegment(Point a1,Point a2,Point b1,Point b2)
{
    double ans=DistanceToSegment(a1,b1,b2);
    ans=min(ans,DistanceToSegment(a2,b1,b2));
    ans=min(ans,DistanceToSegment(b1,a1,a2));
    ans=min(ans,DistanceToSegment(b2,a1,a2));
    return ans;
}
```

###  线

```c++
struct Line{
    Point p;//点
    Vector v;//向量
    double ang;
    Line(){}
    Line(Point p,Vector v):p(p),v(v){ang=atan2(v.y,v.x);}
    Point point(double t){return p+v*t;}
    bool operator <(const Line& L)const{
        return ang<L.ang;
    }
};
//点在直线的左边
bool OnLeft(Line l,Point p)
{
    return Cross(l.v,p-l.p)>0;
}
//两直线交点
Point GetIntersection(Line a,Line b)
{
    Vector u=a.p-b.p;
    double t=Cross(b.v,u)/Cross(a.v,b.v);
    return a.p+a.v*t;
}
```

### 多边形

```c++
typedef vector<Point> Polygon;
//多边形的有向面积，逆时针为正
double PolygonArea(Polygon po) {
    int n = po.size();
    double area = 0.0;
    for(int i = 1; i < n-1; i++) {
        area += Cross(po[i]-po[0], po[i+1]-po[0]);
    }
    return area * 0.5;
}
//点是否在多边形内
int isPointInPolygon(Point p,Point poly[],int n)
{
    int wn=0;
    for(int i=0;i<n;i++){ 
        if(poly[i]==p||poly[(i+1)%n]==p||OnSegment(p,poly[i],poly[(i+1)%n]))return -1;
        int k=dcmp(Cross(poly[(i+1)%n]-poly[i],p-poly[i]));
        int d1=dcmp(poly[i].y-p.y);
        int d2=dcmp(poly[(i+1)%n].y-p.y);
        if(k>0&&d1<=0&&d2>0)
            wn++;
        if(k<0&&d2<=0&&d1>0)
            wn--;
    }
    if(wn!=0)return 1;//内部
    return 0;//外部
}
//求凸包，ch为返回凸包，m为凸包内点的数目，<=不允许点在边上，
int ConvecHull(Point* p,int n,Point* ch)
{
    sort(p,p+n);
    int m=0;
    for(int i=0;i<n;i++){
        while(m>1&&dcmp(Cross(ch[m-1]-ch[m-2],p[i]-ch[m-2])<=0))m--;//注意<=与<的区别
        ch[m++]=p[i];
    }
    int k=m;
    for(int i=n-2;i>=0;i--){
        while(m>k&&dcmp(Cross(ch[m-1]-ch[m-2],p[i]-ch[m-2])<=0))m--;//注意<=与<的区别
        ch[m++]=p[i];
    }
    if(n>1)m--;
    return m;
}
```

### 圆

```c++
struct Circle{
    Point c;
    double r;
    Circle(){};
    Circle(Point c,double r=0):c(c),r(r){}
    Point point(double a){
        return Point(c.x+cos(a)*r,c.y+sin(a)*r);
    }
};
//求圆与直线的交点,t1,t2为(at+b)^2+(ct+d)^2=r^2的解，交点放入sol
int getLineCircleIntersection(Line L,Circle C,double& t1,double& t2,vector<Point>& sol)
{
    double a=L.v.x,b=L.p.x-C.c.x,c=L.v.y,d=L.p.y-C.c.y;
    double e=a*a+c*c,f=2*(a*b+c*d),g=b*b+d*d-C.r*C.r;
    double delta=f*f-4*e*g;
    if(dcmp(delta)<0)return 0;
    if(dcmp(delta)==0){
        t1=t2=-f/(2*e);
        sol.push_back(L.point(t1));
        return 1;
    }
    t1=(-f-sqrt(delta))/(2*e);
    sol.push_back(L.point(t1));
    t2=(-f+sqrt(delta))/(2*e);
    sol.push_back(L.point(t2));
    return 2;
}
//求圆与圆的交点，交点放入sol
int getCircleCircleIntersection(Circle C1,Circle C2,vector<Point>& sol)
{
    double d=Length(C1.c-C2.c);
    if(dcmp(d)==0){
        if(dcmp(C1.r-C2.r)==0)return -1;//两圆重合
        return 0;
    }
    if(dcmp(C1.r+C2.r-d)<0)return 0;
    if(dcmp(fabs(C1.r-C2.r)-d)>0)return 0;
    double  a=angle(C2.c-C1.c);//直线c1c2
    double da=acos((C1.r*C1.r+d*d-C2.r*C2.r)/(2*C1.r*d));//c1c2到c1p1的角
    Point p1=C1.point(a-da),p2=C1.point(a+da);
    sol.push_back(p1);
    if(p1==p2)return 1;
    sol.push_back(p2);
    return 2;
}
//求直线与圆的切线
int getTangents(Point p,Circle C,Vector* v){
    Vector u=C.c-p;
    double dist=Length(u);
    if(dcmp(dist-C.r)<0)return 0;
    else if(dcmp(dist-C.r)==0){
        v[0]=Rotate(u,PI/2);
        return 1;
    }
    else {
        double ang=asin(C.r/dist);
        v[0]=Rotate(u,-ang);
        v[1]=Rotate(u,+ang);
        return 2;
    }
}
```

### 半平面交

```c++
int HalfplaneIntersection(Line* L,int n,Point* poly)
{
    sort(L,L+n);
    int first,last;
    Point *p=new Point[n];//会在函数内开大容量数组，请在使用时注意开成全局！！！！！
    Line *q=new Line[n];//会在函数内开大容量数组，请在使用时注意开成全局！！！！！
    q[first=last=0]=L[0];
    for(int i=1;i<n;i++){
        while(first<last&&!OnLeft(L[i],p[last-1]))last--;
        while(first<last&&!OnLeft(L[i],p[first]))first++;
        q[++last]=L[i];
        if(fabs(Cross(q[last].v,q[last-1].v))<eps){
            last--;
            if(OnLeft(q[last],L[i].p))q[last]=L[i];
        }
        if(first<last)p[last-1]=GetIntersection(q[last-1],q[last]);
    }
    while(first<last&&!OnLeft(q[first],p[last-1]))last--;
    if(last-first<=1)return 0;
    p[last]=GetIntersection(q[last],q[first]);

    int m=0;
    for(int i=first;i<=last;i++)poly[m++]=p[i];
    return m;
}//会在函数内开大容量数组，请在使用时注意开成全局
```

### 平面直线图（PSGL）

```c++
struct Edge
{
    int from, to; // 起点，终点，左边的面编号
    double ang;
    Edge(int f,int t,double a):from(f),to(t),ang(a) {}
};
// 平面直线图（PSGL）实现
struct PSLG {
    int n, m, face_cnt;
    double x[maxn], y[maxn];
    vector<Edge> edges;
    vector<int> G[maxn];
    int vis[maxn*2];  // 每条边是否已经访问过
    int left[maxn*2]; // 左面的编号(该边在哪个面内)
    int prev[maxn*2]; // 相同起点的上一条边（即顺时针旋转碰到的下一条边）的编号

    vector<Polygon> faces;
    double area[maxn]; // 每个polygon的面积

    void init(int n) {
        this->n = n;
        for(int i = 0; i < n; i++) G[i].clear();
        edges.clear();
        faces.clear();
    }

    // 有向线段from->to的极角
    double getAngle(int from, int to) {
        return atan2(y[to]-y[from], x[to]-x[from]);
    }

    void AddEdge(int from, int to) {
        edges.push_back((Edge){from, to, getAngle(from, to)});
        edges.push_back((Edge){to, from, getAngle(to, from)});
        m = edges.size();
        G[from].push_back(m-2);
        G[to].push_back(m-1);
    }

    // 找出faces并计算面积
    void Build() {
        for(int u = 0; u < n; u++) {
            // 给从u出发的各条边按极角排序
            int d = G[u].size();
            for(int i = 0; i < d; i++)
                for(int j = i+1; j < d; j++) // 这里偷个懒，假设从每个点出发的线段不会太多
                    if(edges[G[u][i]].ang > edges[G[u][j]].ang) swap(G[u][i], G[u][j]);
            for(int i = 0; i < d; i++)
                prev[G[u][(i+1)%d]] = G[u][i];  //u点出发的第i条边顺时针转的第一条边是prev[i]
        }

        memset(vis, 0, sizeof(vis));
        face_cnt = 0;
        for(int u = 0; u < n; u++)
            for(int i = 0; i < G[u].size(); i++) {
                int e = G[u][i];  //逆时针转的第i条边
                if(!vis[e]) { // 逆时针找圈
                    face_cnt++;
                    Polygon poly;
                    for(;;) {
                        vis[e] = 1; left[e] = face_cnt;
                        int from = edges[e].from;
                        poly.push_back(Point(x[from], y[from]));
                        //cout<<x[from]<<"   "<<y[from]<<"   ";
                        e = prev[e^1];                    //反向边顺时针第一条
                        if(e == G[u][i]) break;       //回到原点
                        assert(vis[e] == 0);
                    }
                    //cout<<endl;
                    faces.push_back(poly);
                }
            }

        for(int i = 0; i < faces.size(); i++) {
            area[i] = PolygonArea(faces[i]);
        }
    }
};
```

### 旋转卡壳

```c++
//向量(b-a)与向量（c-a)的叉积，相当于三角形abc的有向面积的2倍
double cross(Point a,Point b,Point c)
{
    return Cross(b-a,c-a);
}

//求凸包内最远点
long long getmaxdistance(Point a[],int n)
{
    int j=2;
    double ans=0;
    a[n]=a[0];//方便写下一个点，避免取模
    for(int i=0;i<n;i++){
        while(fabs(cross(a[i],a[i+1],a[j+1]))>fabs(cross(a[i],a[i+1],a[j])))j=(j+1)%n;
        //通过比较面积大小，比较到直线的距离
        ans=max(ans,Length2(a[j]-a[i]));
    }
    return ans;
}

//求2个凸包间的最短距离
double getmindistance(Point p1[],Point p2[],int n1,int n2)
{
    int i=0,j=0;
    for(int k=0;k<n1;k++){
        if(p1[k].y<p1[i].y)i=k;//找出p1中的y最小值的点
    }
    for(int k=0;k<n2;k++){
        if(p2[k].y>p2[j].y)j=k;//找出p2中的y最大值的点
    }
    p1[n1]=p1[0];
    p2[n2]=p2[0];
    double ans=99999999999;
    for(int k=0;k<n1;k++){
        //循环n1次，相当于求p1中每一条边与p2的最近距离
        while((cross(p1[i],p1[i+1],p2[j+1])-cross(p1[i],p1[i+1],p2[j]))>eps)
            j=(j+1)%n2;
        ans=min(ans,disSegmenttoSegment(p1[i],p1[i+1],p2[j],p2[j+1]));//求线段间的最短距离
        i=(i+1)%n1;
    }
    return ans;
}

//求凸包的内4个点组成的最大四边形面积
double solve(Point a[],int n)
{
    a[n]=a[0];
    int p1,p2;
    double ans=0;
    for(int i=0;i<n;i++){
        p1=(i+0)%n;
        p2=(i+1)%n;
        for(int j=i+1;j<n;j++){
            while(cross(a[i],a[j],a[p1+1])<cross(a[i],a[j],a[p1]))p1=(p1+1)%n;
            while(cross(a[i],a[j],a[p2+1])>cross(a[i],a[j],a[p2]))p2=(p2+1)%n;
            ans=max(ans,cross(a[i],a[j],a[p2])-cross(a[i],a[j],a[p1]));
        }
    }
    return ans;
}
```

