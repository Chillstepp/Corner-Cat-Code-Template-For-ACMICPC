[TOC]

# 图论

## 网络流

### 匈牙利算法

求二分图最大匹配，最坏情况下时间复杂度是$O(n^3)$，但一般情况下会是$O(n^2)$

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=2000;
vector<int> g[maxn+5];
bool v[maxn+5];
int f[maxn+5];
int n,m;
void addedge(int u,int v)
{
    g[u].push_back(v);
    g[v].push_back(u);
}
bool dfs(int k)
{
    for(int i=0;i<g[k].size();++i)
        if(v[g[k][i]]==0)
        {
            v[g[k][i]]=1;
            if(f[g[k][i]]==0||dfs(f[g[k][i]]))
            {
                f[g[k][i]]=k;
                f[k]=g[k][i];
                return true;
            }
        }
    return false;
}
int main()
{
    scanf("%d %d",&n,&m);
    for(int i=0;i<=n+m;++i) g[i].clear();
    for(int i=n+1;i<=m+n;++i)
    {
        int x,y;
        scanf("%d %d",&x,&y);
        ++x,++y;
        addedge(i,x);
        addedge(i,y);
    }
    memset(f,0,sizeof(f));
    int ans=0;
    for(int i=1;i<=n+m;++i)
    {
        if(f[i]!=0) continue;
        memset(v,0,sizeof(v));
        if(dfs(i)) ++ans;
    }
    printf("%d",ans);
    return 0;
}
```

### 二分图最大独立集/最小点覆盖

```cpp
#include<bits/stdc++.h>
using namespace std;
#define left lsfdlk
const int maxn=5000;
int a[maxn+5];
vector<int> g[maxn+5];
bool inS[maxn+5],inT[maxn+5],ismatch[maxn+5];
bool left[maxn+5];
int f[maxn+5];
int n,m;
void addedge(int u,int v)
{
    g[u].push_back(v);
    g[v].push_back(u);
}
bool dfs(int k)
{
    inS[k]=1;
    for(int i=0;i<g[k].size();++i)
        if(inT[g[k][i]]==0)
        {
            inT[g[k][i]]=1;
            if(f[g[k][i]]==0||dfs(f[g[k][i]]))
            {
                f[g[k][i]]=k;
                f[k]=g[k][i];
                return true;
            }
        }
    return false;
}
int main()
{
    freopen("ce.in","r",stdin);
    scanf("%d",&n);
    for(int i=1;i<=n;++i) scanf("%d",&a[i]);
    for(int i=1;i<=n;++i)
        for(int j=i+1;j<=n;++j)
            if(__builtin_popcount(a[i]^a[j])==1) addedge(i,j);
    for(int i=1;i<=n;++i)
        if(__builtin_popcount(a[i])&1) left[i]=true;
    memset(f,0,sizeof(f));
    for(int i=1;i<=n;++i)
    {
        if(!left[i]) continue; //只遍历左边点
        memset(inT,0,sizeof(inT));
        if(dfs(i)) ismatch[i]=true;
    }
    memset(inS,0,sizeof(inS));
    memset(inT,0,sizeof(inT));
    for(int i=1;i<=n;++i)
        if(left[i]&&!ismatch[i]) dfs(i);
    vector<int> ans;    //最大独立集
    ans.clear();
    for(int i=1;i<=n;++i)
    {
        if(left[i]&&inS[i]) ans.push_back(a[i]);
        if(!left[i]&&!inT[i]) ans.push_back(a[i]);
    }
    cout<<ans.size()<<endl;
    for(auto x:ans) cout<<x<<" ";
    return 0;
}
```



### KM算法

求二分图最优匹配

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef int ll;
const int maxn=407,inf=1e9;
int nl,nr,m;
struct KuhnMunkres
{
    int n;//左边1~n个点，右边1~n个点
    int a[maxn+5][maxn+5];
    int lx[maxn+5],ly[maxn+5],sla[maxn+5];//lx是左边顶标  ly是右边顶标
    int fl[maxn+5],fr[maxn+5];//fl[i]表示左边第i个点匹配右边哪个点 fr[i]表示右边第i个点匹配哪个点
    int vx[maxn+5],vy[maxn+5],pre[maxn+5];
    int q[maxn+5],tp;
    void match(int x)
    {
        while(x)
        {
            fr[x]=pre[x];
            int y=fl[fr[x]];
            fl[fr[x]]=x;
            x=y;
        }
    }
    void find(int x)
    {
        fill(vx,vx+n+1,0);
        fill(vy,vy+n+1,0);
        fill(sla,sla+n+1,inf);
        q[tp=1]=x;vx[x]=1;
        while(1)
        {
            for(int i=1;i<=tp;i++)
            {
                int x=q[i];
                for(int y=1;y<=n;y++)
                {
                    int t=lx[x]+ly[y]-a[x][y];
                    if(vy[y]||t>sla[y])continue;
                    pre[y]=x;
                    if(t==0)
                    {
                        if(!fr[y]){match(y);return;}
                        q[++tp]=fr[y];vy[y]=1;vx[fr[y]]=1;
                    }
                    else sla[y]=t;
            }
        }
        int d=inf;tp=0;
        for(int i=1;i<=n;i++)if(!vy[i]&&d>sla[i])d=sla[i],x=i;
        for(int i=1;i<=n;i++)
        {
            if(vx[i])lx[i]-=d;
            if(vy[i])ly[i]+=d;
            else sla[i]-=d;
        }
        if(!fr[x]){match(x);return;}
        q[++tp]=fr[x];vy[x]=vx[fr[x]]=1;
    }
}
    void solve()
    {
        memset(lx,0,sizeof(lx));
        memset(ly,0,sizeof(ly));
        memset(fl,0,sizeof(fl));
        memset(fr,0,sizeof(fr));
        for(int i=1;i<=n;++i) lx[i]=*max_element(a[i]+1,a[i]+n+1);
        for(int i=1;i<=n;++i) find(i);
    }
}km;
int main()
{
    scanf("%d%d%d",&nl,&nr,&m);
    while(m--)
    {
        int u,v;
        scanf("%d%d",&u,&v);
        scanf("%d",&km.a[u][v]);
    }
    km.n=max(nl,nr);
    km.solve();
    long long ans=0;
    for(int i=1;i<=nl;++i)ans+=km.a[i][km.fl[i]];
    printf("%lld\n",ans);
    for(int i=1;i<=nl;++i)
        if(km.a[i][km.fl[i]]==0) printf("0 ");
        else
            printf("%d ",km.fl[i]);
    return 0;
}
```

### Dinic

求最大流，时间复杂度$O(n^2m)$

**注意初始化len=-1**

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=2000,inf=1e9,maxm=90000;
struct Edge
{
    int from,to,cap,flow;
}edge[maxm*2+5];;
vector <int> g[maxn+5];
int step[maxn];//从源点到点x的距离
int iter[maxn];//定点x的第几条边开始有用
int n,m,S,T,len;
void addedge(int from,int to,int cap)
{
    ++len;
    edge[len]={from,to,cap,0};
    g[from].push_back(len);
    ++len;
    edge[len]={to,from,0,0};
    g[to].push_back(len);
}
void bfs(int S)
{
    memset(step,-1,sizeof(step));
    step[S]=0;
    queue<int> q;
    q.push(S);
    while(!q.empty())
    {
        int v=q.front();
        q.pop();
        for(int i=0;i<g[v].size();++i)
        {
            Edge &e=edge[g[v][i]];
            if(e.cap>e.flow&&step[e.to]<0)
            {
                step[e.to]=step[v]+1;
                q.push(e.to);
            }
        }
    }
}
int dfs(int v,int t,int f)
{
    if(v==t) return f;
    for(int &i=iter[v];i<g[v].size();++i)//这里是引用，i++的同时iter也++，其实相当于上个的used，不过不用判断了
    {
        Edge &e=edge[g[v][i]];
        if(e.cap>e.flow&&step[e.to]>step[v])
        {
            int d=dfs(e.to,t,min(e.cap-e.flow,f));
            if(d>0)
            {
                e.flow+=d;
                edge[g[v][i]^1].flow-=d;
                return d;
            }
        }
    }
    return 0;
}
int maxflow(int S,int T)
{
    int flow=0;
    for(;;)
    {
        bfs(S);
        if(step[T]<0) return flow;
        memset(iter,0,sizeof(iter));
        int f;
        while((f=dfs(S,T,inf))>0)
            flow+=f;
    }
}
int main()
{
        scanf("%d%d",&n,&m);
       S=0,T=n+1;
        for(int i=0;i<=T;++i) g[i].clear();
        len=-1;
        for(int i=1;i<=n;++i)
        {
            int x;
            scanf("%d",&x);
            if(x==0) addedge(S,i,1);else addedge(i,T,1);
        }
        for(int i=0;i<m;++i)
        {
            int u,v;
            scanf("%d%d",&u,&v);
            addedge(u,v,1);
            addedge(v,u,1);
        }
        printf("%d\n",maxflow(S,T));
    return 0;
}
```

### 最大费用最大流（spfa实现）

求最大费用最大流，时间复杂度：**增广次数 $\times$ spfa时间复杂度**

这意味着，即使图很大，但费用很小的情况下，也能快速跑完

**注意初始化len=-1**

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=200,maxm=5000,inf=1e7;
const double eps=1e-12;
struct wjmzbmr
{
    int from,to,cap,flow;
    double cost;
}edge[8*maxm];
vector<int> g[maxn+50];
double d[maxn+50];
int a[maxn+50],b[maxn+50],last[maxn+50],f[maxn+50];
int n,m,t,len,S,T;
bool v[maxn+50];
void add(int from,int to,int cap,double cost)
{
    edge[++len]=(wjmzbmr){from,to,cap,0,cost},g[from].push_back(len);
    edge[++len]=(wjmzbmr){to,from,0,0,-cost},g[to].push_back(len);
}
bool spfa(int S,int T,int &flow,double &cost)
{
    for(int i=0;i<=n+1;++i) d[i]=(double)-inf,f[i]=inf;
    memset(v,0,sizeof(v));
    d[S]=0.0,v[S]=1,last[S]=0,f[S]=inf;
    queue<int> q;
    while(!q.empty()) q.pop();
    q.push(S);
    while(!q.empty())
    {
        int u=q.front();
        q.pop();
        v[u]=0;
        for(int i=0;i<g[u].size();++i)
        {
            wjmzbmr& e=edge[g[u][i]];
            if(e.cap>e.flow&&(d[e.to]+eps<d[u]+e.cost))
            {
                d[e.to]=d[u]+e.cost;
                last[e.to]=g[u][i];
                f[e.to]=min(f[u],e.cap-e.flow);
                if(!v[e.to])
                {
                    q.push(e.to);
                    v[e.to]=1;
                }
            }
        }
    }
    if(d[T]==-inf) return false;
    //if(d[T]*f[T]<0) return false;最大费用可行流
    flow+=f[T];
    cost+=d[T]*f[T];
    int u=T;
    while(u!=S)
    {
        edge[last[u]].flow+=f[T];
        edge[last[u]^1].flow-=f[T];
        u=edge[last[u]].from;
    }
    return true;
}
int main()
{
    scanf("%d",&t);
    while(t--)
    {
        scanf("%d %d",&n,&m);
        len=-1;
        for(int i=0;i<=n;++i) g[i].clear();
        for(int i=1;i<=n;++i) scanf("%d %d",&a[i],&b[i]);
        for(int i=1;i<=m;++i)
        {
            int x,y,z;double p;
            scanf("%d %d %d %lf",&x,&y,&z,&p);
            p=log2(1.0-p);
            if(z==0) continue;
            else
            {
                add(x,y,1,0);
                add(x,y,z-1,p);
            }
        }
        S=0,T=n+1;
        for(int i=1;i<=n;++i)
        {
            if(a[i]-b[i]==0) continue;
            if(a[i]-b[i]>0) add(S,i,a[i]-b[i],0);
            else add(i,T,b[i]-a[i],0);
        }
        int flow=0;double cost=0.0;
        while(spfa(S,T,flow,cost)) ;
        printf("%.2f\n",1.0-pow(2.0,cost));
    }
    return 0;
}
```

### 最小费用最大流（dijkstra实现）



```cpp
#include<bits/stdc++.h>
using namespace std;
#define mp make_pair
const int maxn=2000+5,inf=1e9;
pair<int,int> a[maxn+5];
struct edge
{
    int to,cap,flow,cost,rev;
};
vector<edge> g[maxn+5];
struct heapnode
{
    int id,v;
    bool operator < (const heapnode &t) const
    {
        return v>t.v;
    }
};
priority_queue<heapnode> q;
int n,m,S,T,flow,cost;
int h[maxn+5],dis[maxn+5],cur[maxn+5];
bool ins[maxn+5];
void addedge(int from,int to,int cap,int cost)
{
    g[from].push_back({to,cap,0,cost,(int)g[to].size()});
    g[to].push_back({from,0,0,-cost,(int)g[from].size()-1});
}
bool Dijkstra()
{
    for (int i=0;i<=T;++i)
    {
        h[i]=min(h[i]+dis[i],inf);
        dis[i]=i==S?0:inf;
    }
    q.push(heapnode{S,0});
    while (!q.empty())
    {
        heapnode x=q.top();
        q.pop();
        if(x.v>dis[x.id]) continue;
        for(int i=0;i<g[x.id].size();++i)
        {
            edge e=g[x.id][i];
            if(e.cap>e.flow&&x.v+h[x.id]+e.cost-h[e.to]<dis[e.to])
            {
                dis[e.to]=x.v+h[x.id]+e.cost-h[e.to];
                q.push(heapnode{e.to, dis[e.to]});
            }
        }
    }
    return dis[T]<inf;
}
int dfs(int x,int a)
{
    if(x == T) return a;
    int ans = 0;
    ins[x] = 1;
    for(int &i=cur[x];i<g[x].size();++i)
    {
        edge &e=g[x][i];
        if(!ins[e.to]&&dis[x]+h[x]+e.cost-h[e.to]==dis[e.to]&&e.cap>e.flow)
        {
            int now=dfs(e.to,min(a,e.cap-e.flow));
            e.flow += now;
            g[e.to][e.rev].flow-=now;
            ans+=now;
            a-=now;
            if (!a) break;
        }
    }
    ins[x] = 0;
    return ans;
}
int main()
{
    freopen("ce.in","r",stdin);
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;++i) scanf("%d%d",&a[i].first,&a[i].second); // bottle
    for(int i=n+1;i<=n+m;++i) scanf("%d%d",&a[i].first,&a[i].second); // people
    scanf("%d%d",&a[n+m+1].first,&a[n+m+1].second);
    S=0,T=n+m+2;
    for(int i=n+1;i<=n+m;++i) addedge(S,i,1,0);
    addedge(S,n+m+1,n-1,0);
    for(int i=1;i<=n;++i) addedge(i,T,1,0);
    for(int i=n+1;i<=n+m+1;++i)
        for(int j=1;j<=n;++j)
            addedge(i,j,1,abs(a[i].first-a[j].first)+abs(a[i].second-a[j].second));
    while(Dijkstra())
    {
        memset(cur,0,sizeof(cur));
        int now=dfs(S,inf);
        flow+=now;
        cost+=now*(dis[T]+h[T]-h[S]);
    }
    for(int i=1;i<=n;++i) cost+=abs(a[i].first-a[n+m+1].first)+abs(a[i].second-a[n+m+1].second);
    printf("%d",cost);
    return 0;
}
```

## 连通分量

### 有向图

#### 两次DFS

时间复杂度$O(n+m)$

可用bitset优化

```cpp
#include<cstring>
#include<cstdio>
#include<algorithm>
#include<vector>
using namespace std;
const int maxn=1e5,inf=1e9;
vector < int > g[maxn+50],g1[maxn+50],g2[maxn+50];
bool v[maxn+50];
int n,m,color[maxn+50],t[maxn+50],len,c,d[maxn+50];
void dfs(int k)
{
    v[k]=1;
    for(int i=0;i<g[k].size();++i)
        if(!v[g[k][i]]) dfs(g[k][i]);
    ++len;
    t[len]=k;
}
void dfs1(int k)
{
    v[k]=1;
    color[k]=c;
    for(int i=0;i<g1[k].size();++i)
        if(!v[g1[k][i]]) dfs1(g1[k][i]);
}
bool check2(int a,int b)
{
    if(a==b) return 0;
    for(int i=0;i<g2[a].size();++i)
        if(g2[a][i]==b) return 0;
    return 1;
}
int main()
{

    while(scanf("%d %d",&n,&m)!=EOF)
    {
        c=0;
        len=0;
        memset(d,0,sizeof(d));
    for(int i=0;i<=n;++i) g[i].clear(),g1[i].clear(),g2[i].clear();
    for(int i=1;i<=m;++i)
    {
        int x,y;
        scanf("%d %d",&x,&y);
        g[x].push_back(y);
        g1[y].push_back(x);
    }
    memset(v,0,sizeof(v));
    memset(t,0,sizeof(t));
    for(int i=1;i<=n;++i) if(!v[i]) dfs(i);
    memset(v,0,sizeof(v));
    for(int i=len;i>=1;--i) if(!v[t[i]]) ++c,dfs1(t[i]);
    for(int i=1;i<=n;++i)
        for(int j=0;j<g[i].size();++j)
            if(check2(color[i],color[g[i][j]]))
                g2[color[i]].push_back(color[g[i][j]]),++d[color[i]];
    int s=0,x=0;
    for(int i=1;i<=c;++i) if(d[i]==0) ++s,x=i;
    if(s>1) printf("0\n");
    else
    {
        int ans=0;
        for(int i=1;i<=n;++i)
            if(color[i]==x) ++ans;
        printf("%d\n",ans);
    }
    }
    return 0;
}
/*bitset优化*/
void dfs(int k)
{
    if(vis[k]==0) return;
    vis.reset(k);
    bitset<maxn+5> nx=vis&g[k];
    int u=nx._Find_first();
    while(u<=n)
    {
        dfs(u);
        u=nx._Find_next(u);
    }
    a.push_back(k);
}
void dfs1(int k)
{
    if(vis[k]==0) return;
    vis.reset(k);
    bitset<maxn+5> nx=vis&g1[k];
    int u=nx._Find_first();
    while(u<=n)
    {
        dfs1(u);
        u=nx._Find_next(u);
    }
}
```

### 无向图(Tarjan)

#### 点双

注意一个点可能会出现在多个点双里面

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1000,maxm=1000000;
vector<int> g[maxn+50],bcc[maxn+50];
int dfstime[maxn+50],low[maxn+50],color[maxn+50],head[maxn+50];
bool p[maxn+5][maxn+5],map[maxn+5][maxn+5],flag;
int n,m,top,c,t;
bool ins[maxn+50];
struct wjmzbmr
{
    int u,v;
}s[maxm];
void tarjan(int k,int fa)
{
    low[k]=dfstime[k]=++t;
    for(int i=0;i<g[k].size();++i)
    {
        int u=g[k][i];
        if(u==fa) continue;
        if(dfstime[u])
            if(dfstime[u]<dfstime[k]) low[k]=min(low[k],dfstime[u]),s[++top]={k,u};
            else;
        else
        {
            s[++top]={k,u};
            tarjan(u,k);
            low[k]=min(low[k],low[u]);
            if(low[u]>=dfstime[k])
            {
                ++c;
                while(1)
                {
                    wjmzbmr e=s[top--];
                    if(color[e.u]!=c)
                    {
                        bcc[c].push_back(e.u);
                        color[e.u]=c;
                    }
                    if(color[e.v]!=c)
                    {
                        bcc[c].push_back(e.v);
                        color[e.v]=c;
                    }
                    if(e.u==k&&e.v==u) break;
                }
            }
        }
    }
}
int main()
{
    scanf("%d %d",&n,&m);
    while(!(n==0&&m==0))
    {
        for(int i=0;i<=n;++i) g[i].clear(),bcc[i].clear();
        memset(p,0,sizeof(p));
        for(int i=1;i<=m;++i)
        {
            int x,y;
            scanf("%d %d",&x,&y);
            p[x][y]=p[y][x]=1;
        }
        for(int i=1;i<=n;++i)
            for(int j=1;j<=n;++j)
                if(i!=j&&!p[i][j]) g[i].push_back(j);
        memset(dfstime,0,sizeof(dfstime));
        memset(s,0,sizeof(s));
        memset(color,0,sizeof(color));
        top=c=t=0;
        for(int i=1;i<=n;++i)
            if(!dfstime[i]) tarjan(i,-1);
        scanf("%d %d",&n,&m);
    }
    return 0;
}
```

#### 边双

时间复杂度$O(n+m)$

一个点只会出现在一个边双里，桥隔开了所有的边双

```cpp
#include<bits\stdc++.h>
using namespace std;
const int maxn=4e5;
struct wjmzbmr
{
    int x,y,pos;
};
wjmzbmr e[2*maxn+50];
vector<int> g[maxn+50];
int dfstime[maxn+50],low[maxn+50],s[maxn+50],color[maxn+50],num[maxn+50];
int n,m,top,c,t,ans1=0;
bool ins[maxn+50];
void tarjan(int k,int fa)
{
    low[k]=dfstime[k]=++t;
    s[++top]=k;
    ins[k]=1;
    for(int i=0;i<g[k].size();++i)
    {
        int u=e[g[k][i]].y;
        if(fa==u) continue;
        if(!dfstime[u])
        {
            tarjan(u,k);
            //if(low[u]>dfstime[k]) p[g[k][i]]=1; 判断此边是否为桥
            low[k]=min(low[k],low[u]);
        }
        else
            if(ins[u]) low[k]=min(low[k],low[u]);
    }
    if(dfstime[k]==low[k])
    {
        ++c;
        while(1)
        {
            int v=s[top--];
            ins[v]=0,color[v]=c,++num[c];
            if(v==k) break;
        }
    }
}
int main()
{
    scanf("%d %d",&n,&m);
    for(int i=0;i<=n;++i) g[i].clear();
    for(int i=1;i<=m;++i)
    {
        int x,y;
        scanf("%d %d",&x,&y);
        g[x].push_back(2*i-1),g[y].push_back(2*i);
        e[2*i-1]={x,y,i},e[2*i]={y,x,i};
    }
    memset(dfstime,0,sizeof(dfstime));
    for(int i=1;i<=n;++i) low[i]=n+1;
    memset(color,0,sizeof(color));
    memset(num,0,sizeof(num));
    memset(s,0,sizeof(s));
    memset(ins,0,sizeof(ins));
    top=c=t=0;
    tarjan(1,-1);
    return 0;
}
```



## 图的非递归遍历

```cpp
void dfs(int k,int last)
{
   /* L[k]=++t;
    deep[k]=deep[last]+1;
    fa[k][0]=last;
    for(int i=0;i<g[k].size();++i)
        if(g[k][i]!=last) dfs(g[k][i],k);
    R[k]=t;*/
    while(!s.empty()) s.pop();
    memset(head,0,sizeof(head));//head[i]表示第i个点当前遍历到了第几个相邻点
    s.push(0);
    s.push(1);
    while(s.size()>1)
    {
        int k=s.top();
        s.pop();
        int last=s.top();
        s.push(k);
        if(!head[k])
        {
            L[k]=++t;
            deep[k]=deep[last]+1;
            fa[k][0]=last;
        }
        if(head[k]<g[k].size())
            if(g[k][head[k]]==last) ++head[k];
        if(head[k]==g[k].size())
        {
            R[k]=t;
            s.pop();
        }
        else
            s.push(g[k][head[k]++]);
    }
}
```

